#lang ivy1.6

# almost everything is in the TLA+ spec is a natural number here

type node
interpret node -> nat

relation succ(X: node, Y: node)
axiom forall X. forall Y. forall Z. succ(X, Y) <-> (X < Y & ~(X < Z & Z < Y))

individual n: node
individual t: node
individual f: node
axiom (n >= 1) & (n > 5 * t) & (t >= f)

function correct(P: node): bool
definition correct(P) = ((1 <= P) & (P <= n - f))

function all(P: node): bool
definition all(P) = ((1 <= P) & (P <= n))

type rounds
interpret rounds -> nat
individual rmax: rounds # maximum number of rounds

type allV = {0..2} # NoDecision is 2 in IVy
type steps = {1..3}

# functions are immutable so they are seen as relations unlike the TLA+ spec
relation value(P: node, V: allV)
relation decision(P: node)
relation round(P: node, R: rounds)
relation step(P: node, S: steps)

relation type1(R: rounds, P: node, V: allV)
relation type2D(R: rounds, P: node, V: allV)
relation type2Q(R: rounds, P: node)

# notion of receiving messages through a subset of processes
type quorum
relation member(P: node, Q: quorum)

function cardUpTo(P: node, Q: quorum): node
axiom cardUpTo(1, Q) = (1 if member(A, Q) else 0)
axiom succ(X, Y) -> cardUpTo(Y, Q) = cardUpTo(X, Q) + (1 if member(Y, Q) else 0) 

function card(Q: quorum): node
definition card(Q) = cardUpTo(n, Q)

### init and possible actions

after init {
    value(P, V) := false;
    value(P, 2) := true;

    decision(P) := false;

    round(P, R) := false;
    round(P, 0) := true;

    step(P, S) := false;
    step(P, 1) := true;

    type1(R, P, V) := false;
    type1(R, P, 2) := true;

    type2D(R, P, V) := false;
    type2D(R, P, 2) := true;
    type2Q(R, P) := false;
}

# extra step to implement non-determinism and get values
action step0(p: node) = {
    assume correct(p) & value(p, 2);

    value(p, 2) := false;
    if * {
        value(p, 0) := true;
    } else {
        value(p, 1) := true;
    }
}

action step1(p: node, r: rounds, v: allV) = {
    # wait for all correct processes to have a value before starting
    assume forall P. correct(P) -> (~value(p, 2)); 
    assume correct(p) & step(p, 1) & round(p, r) & value(p, v);

    type1(r, p, 2) := false;
    type1(r, p, v) := true;

    step(p, 1) := false;
    step(p, 2) := true;
}

action step2(p: node, r: rounds, q: quorum, q0: quorum, q1: quorum) = {
    assume correct(p) & step(p, 2) & round(p, r) & card(q) = n - t;

    # q is the set of received messages
    # q0 is the set of received messages with value 0
    # q1 is the set of received messages with value 1
    assume forall P. member(P, q) -> (type1(r, P, 0) | type1(r, P, 1));
    assume forall P. (member(P, q0) | member(P, q1)) -> member(P, q);
    assume forall P. member(P, q0) -> type1(r, P, 0);
    assume forall P. member(P, q1) -> type1(r, P, 1);

    if 2 * card(q0) > n + t {
        type2D(r, p, 2) := false;
        type2D(r, p, 0) := true;
    } else {
        if (2 * card(q1) > n + t) {
            type2D(r, p, 2) := false;
            type2D(r, p, 1) := true;
        } else {
            type2Q(r, p) := true;
        }
    }
    step(p, 2) := false;
    step(p, 3) := true;
}

action step3(p: node, r: rounds, q: quorum, q0: quorum, q1: quorum) = {
    assume correct(p) & step(p, 3) & round(p, r) & card(q) = n - t;
    assume r + 1 <= rmax;

    assume forall P. member(P, q) -> (type2D(r, P, 0) | type2D(r, P, 1) | type2Q(r, P));
    assume forall P. (member(P, q0) | member(P, q1)) -> member(P, q);
    assume forall P. member(P, q0) -> type2D(r, P, 0);
    assume forall P. member(P, q1) -> type2D(r, P, 1);

    if card(q0) <= t & card(q1) <= t {
        if * {
            value(p, 1) := false;
            value(p, 0) := true;
        } else {
            value(p, 0) := false;
            value(p, 1) := true;
        }
    } else {
        # a bit different to TLA+ since if both card(q0) > t and card(q1) > t,
        # the TLA+ spec would randomly choose a value to go ahead with
        if card(q0) > t {
            value(p, 1) := false;
            value(p, 0) := true;
            if 2 * card(q0) > n + t {
                decision(p) := true;
            }
        } else {
            value(p, 0) := false;
            value(p, 1) := true;
            if 2 * card(q1) > n + t {
                decision(p) := true;
            }
        }
    }
    round(p, r) := false;
    round(p, r + 1) := true;
    step(p, 3) := false;
    step(p, 1) := true;
}

# injecting each type of message once
action faultyType1(p: node, r: rounds) = {
    assume all(p) & ~correct(p) & r <= rmax & type1(r, p, 2);
    type1(r, p, 2) := false;
    if * {
        type1(r, p, 0) := true;
    } else {
        type1(r, p, 1) := true;
    }
}

action faultyType2D(p: node, r: rounds) = {
    assume all(p) & ~correct(p) & r <= rmax & type2D(r, p, 2);
    type2D(r, p, 2) := false;
    if * {
        type2D(r, p, 0) := true;
    } else {
        type2D(r, p, 1) := true;
    }
}

action faultyType2Q(p: node, r: rounds) = {
    assume all(p) & ~correct(p) & r <= rmax & ~type2Q(r, p);
    type2Q(r, p) := true;
}

conjecture forall P. forall Q. forall V. 
    (correct(P) & correct(Q) & decision(P) & decision(Q)) -> (value(P, V) = value(Q, V))

# required for ivy_check to recognise these actions
export step0
export step1
export step2
export step3
export faultyType1
export faultyType2D
export faultyType2Q